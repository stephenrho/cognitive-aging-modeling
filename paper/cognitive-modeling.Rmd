---
title             : "A Tutorial on Cognitive Modeling for Cognitive Aging Research"
shorttitle        : "Modeling Cognitive Aging"

author: 
  - name          : "Nathaniel R. Greene"
    affiliation   : "1"
    corresponding : yes
    address       : "9J McAlester Hall, Department of Psychological Sciences, University of Missouri, Columbia, MO 65211"
    email         : "ngreene@mail.missouri.edu"
  - name          : "Stephen Rhodes"
    affiliation   : "2"

affiliation:
  - id            : "1"
    institution   : "Department of Psychological Sciences, University of Missouri"
  - id            : "2"
    institution   : "Rotman Research Institute, Baycrest Health Sciences, Toronto ON, Canada"

note: |
  Draft: `r format(Sys.time(), '%d %B %Y')`
authornote: |
  Data and code available at https://github.com/stephenrho/cognitive-aging-modeling
  Both authors contributed equally; author order is alphabetical. This paper was written with the papaja package (Aust & Barth, 2020). The authors thank Alicia Forsberg and John Scofield for helpful feedback. 

abstract: |
  Cognitive aging researchers are interested in understanding how cognitive processes change in old age, but the relationship between hypothetical latent cognitive processes and observed behavior is often complex and not fully accounted for in standard analyses (e.g., ANOVA). Cognitive models formalize the relationship between underlying processes and observed behavior and are more suitable for identifying what processes are associated with aging. This article provides a tutorial on how to fit and interpret cognitive models to measure age differences in cognitive processes. We work with an example of a two choice discrimination task and describe how to fit models in the highly flexible modeling software Stan. We describe how to use hierarchical modeling to estimate both group and individual effects simultaneously, and we detail model fitting in a Bayesian statistical framework, which, among other benefits, enables aging researchers to quantify evidence for null effects. We contend that more widespread use of cognitive modeling among cognitive aging researchers may be useful for addressing potential issues of non-replicability in the field, as cognitive modeling is more suitable to addressing questions about what cognitive processes are (or are not) affected by aging.    

keywords          : "Signal Detection Theory; Cognitive Aging; Mathematical Models"

bibliography      : ["refs.bib"]
no-cite: |
  @R-papaja, @bayen1996source, @MeiserAndBroder2002, @BoywittEtAl2012, @SnodgrassAndCorwin1988, @yonelinas1994receiver, @RouderEtAl2011, @Ratcliff1978, @ratcliff2008diffusion, @BrownAndHeathcote2008, @wagenmakers2007ez, @zhang2008discrete, @bays2009precision, @rhodes2020age, @souza2016no, @van2012variability, @oberauer2017interference, @AshbyAndMaddox1993, @MaddoxEtAl2013, @MaddoxAndAshby1993, @NivEtAl2015, @WilsonAndNiv2012, @YuAndDayan2005

figsintext        : yes
figurelist        : no
tablelist         : no
footnotelist      : no
lineno            : no
mask              : no
urlcolor          : blue
class             : "man"
output            : papaja::apa6_pdf
header-includes:
  - \raggedbottom
  - \interfootnotelinepenalty=10000
  - \usepackage{lscape}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F)

#setwd("../code/")
knitr::opts_knit$set(root.dir = normalizePath("../"))

library(rstan)
library(bayesplot)
library(xtable)

SDT <- function(d, k, s = 1){
  f = pnorm(-d/2 - k)
  h = pnorm((d/2 - k)/(1/s))
  return(c(f = f, h = h))
}

ratingModel <- function(d, s, a, b, C, ratingProbs = T, lastPoint = T){
  # the parsimonius model from Selker et al
  # https://osf.io/v3b76/
  unb = -log((1 - 1:C/C)/(1:C/C))
  
  thresh = a*unb + b
  
  f = (diff(pnorm(c(-Inf, thresh),0,1)))
  h = (diff(pnorm(c(-Inf, thresh),d,s)))
  if (!ratingProbs){
    f = cumsum(rev(f))
    h = cumsum(rev(h))
  }
  
  if(!lastPoint){
    f = f[1:(C-1)]
    h = h[1:(C-1)]
  }
  
  return(cbind(f, h))
}

plotSDT <- function(d = 2, s = 1, a = 1, b = 0, C = 6, title = F, allpars=F){
  par(pty='m', mar=c(3,2,.5,.5))
  
  newcol = col2rgb("dodgerblue4")[,1]
  newcol = rgb(red = newcol[1], green = newcol[2], blue = newcol[3], alpha = 50, maxColorValue = 255)
  oldcol=rgb(1,1,1,.5)
  xrange = c(-3, d+3*s)
  yrange = c(0, max(dnorm(0), dnorm(d, d, s)))
  
  yscale = ifelse(allpars, 1.8, 1.5)
  
  xseq = seq(from=xrange[1], to=xrange[2], length.out = 1000)
  
  unb = -log((1 - 1:C/C)/(1:C/C))
  thresh = a*unb + b
  thresh = thresh[1:(C-1)]
  
  plot(NA, ylim = yrange*c(0,yscale), xlim = xrange, ylab="", xlab="", axes=F)
  
  polygon(c(xrange[1], xseq, xrange[2]), c(0, dnorm(xseq), 0), col = newcol , border = NA)
  curve(expr = dnorm(x, 0, 1), from=xrange[1], to=xrange[2], n = 10000, add = T)
  polygon(c(xrange[1], xseq, xrange[2]), c(0, dnorm(xseq, d, s), 0), col = oldcol , border = NA)
  curve(expr = dnorm(x, d, s), from=xrange[1], to=xrange[2], n = 10000, add = T)
  
  for (k in 1:(C-1)){
    lines(x = c(thresh[k], thresh[k]), y = yrange*c(0, 1.35), lty=2, col='darkgrey')
    text(x = thresh[k], y = yrange[2]*1.4, labels = bquote('c'[.(k)]))
  }
  
  label_x = c(xrange[1], thresh, xrange[2])[1:C] + diff(c(xrange[1], thresh, xrange[2]))/2
  
  text(x = label_x, y = yrange[2]*1.2, labels = 1:C, col='red')
  
  if (allpars){
    dlaby = yrange[2]*1.6
    segments(x0 = 0, x1 = d, y0 = dlaby)
    segments(x0 = 0, x1 = 0, y0 = dlaby-yrange[2]*.05, y1 = dlaby+yrange[2]*.05)
    segments(x0 = d, x1 = d, y0 = dlaby-yrange[2]*.05, y1 = dlaby+yrange[2]*.05)
    text(x = d/2, y = dlaby+yrange[2]*.1, labels = bquote(italic(d)))
    
    slaby = dnorm(d, d, s)/2
    segments(x0 = d, x1 = d+s, y0 = slaby)
    segments(x0 = d, x1 = d, y0 = slaby-yrange[2]*.05, y1 = slaby+yrange[2]*.05)
    segments(x0 = d+s, x1 = d+s, y0 = slaby-yrange[2]*.05, y1 = slaby+yrange[2]*.05)
    text(x = d+s/2, y = slaby+yrange[2]*.1, labels = bquote(italic(s)))
  }
  
  axis(1)#; box()
  
  if (title){
    mtext(text = paste0("d = ", d, ", s = ", s, ", a = ", a, ", b = ", b))
  }
}

#plotSDT(d = ps[1], s = ps[2], a = ps[3], b = ps[4], C = ps[5], allpars = T)

```

Cognitive aging researchers aim to understand how cognitive processes change across the adult lifespan, particularly into old age. However, it is impossible to observe a "cognitive process" directly; rather, we must infer cognitive processes from observed behavior (e.g., accuracy, reaction time/RT). One way this is commonly done is by submitting raw or aggregated (e.g., mean RT) data to a *t*-test, ANOVA, or mixed effects model and inferring process(es) through differences between conditions and their interaction with age. However, this interpretation relies on a simple mapping of cognitive processes onto observed behavior, which is unlikely to be the case, and can result in incorrect conclusions about the source of age-differences [see @Salthouse2000]. In contrast to standard analyses, *cognitive models* formalize the relationship between hypothesized underlying processes and observed behavior by way of parameters that reflect the contributions of latent cognitive processes, and are therefore more suitable for identifying what processes are (or are not) associated with aging. 

This paper provides a tutorial on fitting and interpreting cognitive models in the context of cognitive aging research.[^beyond] There are *many* types of cognitive models, suitable for different tasks, and it would be impossible for us to exhaustively describe and implement all (or even a substantial subset) of them. In the section "How Widespread is Cognitive Modeling in Cognitive Aging Research?" we assess 10 years of *Psychology and Aging* and identify several models that appear to be popular with cognitive aging researchers (see Table \ref{tab:oth}). In this tutorial, we use an example of a two choice discrimination task, given that this kind of task is widely used in cognitive aging research, and we focus on implementing a signal detection theory (SDT) model. We have chosen to focus on highly flexible modeling software (Stan), and the tutorial below is written with the intention of generalizing to other areas, so that readers will be able to start implementing models that are relevant to their particular research area.[^sdt] Finally, the tutorial focuses on implementing hierarchical models under a Bayesian statistical framework. Hierarchical modeling allows one to model group level differences as well as individual differences simultaneously, and Bayesian model comparison allows researchers to go beyond null hypothesis significance testing to quantify the strength of evidence for or against age-related changes to particular cognitive processes [we elaborate on the benefits of this approach below; see also, @GelmanEtAl2014; @Kruschke2015; @lee2014bayesian].

[^beyond]: Although the focus here is on comparing groups of different ages, the tutorial will be of use to researchers making other between-group comparisons in cognition.

[^sdt]: Indeed there are existing `R` packages that offer user-friendly implementations of hierarchical SDT models, including `bhsdtr` [@paulewicz2020bhsdtr] and `brms` [@brms; see https://vuorre.netlify.app/post/2017/10/09/bayesian-estimation-of-signal-detection-theory-models-part-1/]. In covering Stan we want to show readers how to implement models from scratch for situations where a user-friendly implementation does not exist or where more control over the details is desired.

This tutorial provides an introduction to cognitive modeling with a particular focus on age-group comparisons. There are many other great resources for learning cognitive modeling in more depth, and we reference many of these in the section "Further Readings." We also acknowledge that mastering cognitive modeling will likely require learning some rather technical concepts. Although we aim to keep this tutorial as accessible as possible for the novice reader, it would be a disservice to avoid technical details where they are necessary. Nevertheless, we aim to break these technical details down into simpler terms to help with understanding. Ultimately, it is our hope that this tutorial will serve as a useful guide and a great starting point for cognitive aging researchers who are interested in learning and applying cognitive modeling.  

## What are the Benefits of Cognitive Modeling? 

The aim of cognitive modeling is to formalize the relationship between theory (i.e., hypothesized cognitive processes and their interaction) and observed behavior and it allows researchers to estimate quantities of interest (i.e., parameter values related to processes). The relationship between underlying processes and behavior can often be counterintuitive, as can be discovered by simulating model behavior under different conditions, and, therefore, a major benefit of cognitive modeling is the ability to formulate *and test* experimental hypotheses at the level of underlying processes (that is, it gets us closer to what we are actually interested in). 

<!--
Perhaps the simplest and most compelling reason to use a model that formalizes the relationship between processes and behavior is that it gets us closer to what we (as cognitive psychologists) are interested in. Consider the following example. The finding that older adults are less likely to recall the source of information is interesting in and of itself, but thinking through the possible underlying processes and formalizing them in, for example, a multinomial processing tree (MPT) model begins to elucidate *why* this is the case. For example, @BoywittEtAl2012, who used the MPT model of multidimensional source memory from @MeiserAndBroder2002, found that, relative to younger adults, older adults were less likely to bind together source dimensions of an episode and did not rely on the retrieval of perceptual features to distinguish source information.
-->

<!--Some may argue that the *why* question-->
Some may argue that questions regarding age-differences in underlying cognitive processes are best addressed by devising clever manipulations that attempt to isolate particular sources of difference. We agree; a model by itself is not enough, and experimental manipulation is necessary for testing ideas about age differences in cognition. However, a robust and replicable effect does not necessarily translate into insight regarding underlying processes. This is perhaps best understood when it comes to interaction effects, where changing the scale of measurement can change the conclusions that one is able to draw [@Loftus1978; @rhodes2019interaction; @WagenmakersEtAl2012]. A recent example from the cognitive aging literature comes from @archambeau2020proactive, who assessed age differences in susceptibility to proactive interference. Specifically, they looked at the recent-probes task in which differences between younger and older participants in errors and RT for lures are greater when those lures were studied on the previous trial relative to non-recent lures. These error and RT findings have been interpreted as showing that older adults have a specific difficulty in inhibiting recently studied, but no longer relevant, information [e.g., @jonides2000age]. However, @archambeau2020proactive applied the drift diffusion model [@Ratcliff1978] and found evidence that older adults were slower than younger adults in the rate of information accumulation (the 'drift rate' parameter) but no evidence that this was especially true for recent lures versus non-recent lures. Thus, what appears as evidence for a greater susceptibility to proactive interference when looking at the raw data can be accounted for without that assumption at the level of cognitive processes [@RotelloEtAl2015 provide other examples of replicable results that have been reassessed with model-based analyses].

<!--
Another advantage of cognitive modeling is that it can provide a more unified measurement approach to reliably characterize age differences on the same task(s) that may be employed in multiple studies. For example, in recent years, memory and aging researchers have become particularly interested in better understanding the nature of older adults' episodic memories. One prominent proposal that has been made to explain a series of related findings that older adults are especially deficient at discriminating between old items (e.g., a red apple) and similar lures (e.g., a green apple) is that older adults' hippocampal pattern separation processes are inefficient [@StarkEtAl2013]. However, the many studies designed to measure old-similar item discrimination as an index of behavioral pattern separation have often employed very different formulas for estimating old-similar discrimination, and these have occasionally led to some rather counterintuitive findings. For example, @ReaghAndYassa2014 found that repeat encoding of an item resulted in surprisingly *worse* old-similar discrimination (though their study was not an aging study, per se). @LoitileAndCourtney2015 applied SDT analyses to a behavioral pattern separation task and found results opposite to those of @ReaghAndYassa2014. They also argued that SDT provides a more reliable method of measuring old-similar discrimination and could be more widely applied to studies purporting to measure behavioral pattern separation.
-->

Beyond the importance of being able to test hypotheses at the level of cognitive processes, a greater shift towards formal modeling in the field of cognitive aging would force researchers to specify their hypotheses in greater detail, relative to the low-level of specificity possible with purely verbal theorizing, which in turn can lead to more diagnostic hypothesis tests [see @oberauer2019addressing]. In addition, fully implementing models in code and sharing them with others, as we do here, makes the theoretical assumptions made completely transparent and reproducible by others [see @guest2021computational for additional benefits of formal modeling for psychological theory].

None of this is to say that cognitive modeling is a magic key that will inevitably unlock the secrets of cognitive aging. For conclusions to be accurate it is important that the model applied is able to mimic the empirical effects seen in the raw data. Therefore, researchers should refer to the wider literature on the adequacy of particular models in particular settings. Often there will be several competing models that account for behavior with different underlying assumptions, in which case researchers may consider comparing models to see which provides the best account of their data set. We cover how to assess model fit as well as how to compare models in this tutorial. In addition, the approach outlined here cannot correct for more fundamental design issues, such as the sampling of participants (i.e., parameter estimates from college students and healthy older adults with an interest in participating in psychologicial research may not generalize to more representative groups).

## Why Use Hierarchical Bayesian Estimation?

When fitting a cognitive model typically the researcher must decide whether to fit the model to the data set as a whole, ignoring individual variability, or to each individual separately, in which case often a large number of trials is needed and additional analysis is required to look at group level trends. A hierarchical model is a compromise between these two extremes in which individual level parameters are constrained by a group level distribution [@GelmanAndHill2007], and these models are handled especially well under a Bayesian statistical framework [@GelmanEtAl2014; @lee2011cognitive; @McElreath2016]. Hierarchical models are also easily extended to account for sources of variability beyond that attributable to participant differences. For example, the items or stimuli used in a particular experiment can be an additional source of variation in performance, and failure to take this into account can increase false discovery [@clark1973language]. This tutorial covers how to include such item effects in a cognitive model.

The ability to simultaneously model group and individual effects, as well as the ability to account for stimulus variability is particularly important in the context of cognitive modeling [see @lee2011cognitive for more discussion of the benefits of hierarchical Bayesian methods for cognitive modeling]. Specifically, cognitive models are often non-linear in that hypothetical processes are mapped onto observed behavior through non-linear functions. For example, in SDT, sensitivity, or $d'$, is mapped onto accuracy through the "S" shaped normal cumulative distribution function. Failure to account for participant and/or item variability can cause systematic bias in parameter estimates that are not correctable via replication [as the bias is systematic; see, e.g., @estes1956problem; @heathcote2000power; @morey2008problematic; @pratte2012assessing; @rouder2005introduction].[^rep]

[^rep]: In the linear case, failure to account for participant or item variability increases the type I error rate but does not produce systematic bias; therefore, replication would act as intended: as a check on false discovery. See @rouder2005introduction for a detailed discussion.

## How Widespread is Cognitive Modeling in Cognitive Aging Research?

We surveyed all articles published between the years 2011 and 2020 in *Psychology and Aging* to get a sense of the prevalence of cognitive modeling in cognitive aging research. For each year, we selected articles that included some measure of cognition (e.g., memory, inhibition, learning, decision making, executive functions). For published papers reporting multiple experiments, we counted each experiment in the paper separately. Although there was some variability in the number of published cognitive aging experiments per year, on average there were about 56 (*M* = 55.70, *SD* = 20.58). 

For each study, we recorded what the dependent variables were and how they were analyzed. We assume that all cognitive studies were interested in making some claims about cognition, but we are primarily interested in the proportion of studies that attempted to measure an underlying latent processes. This could either involve transforming the observed data using a simple formula, such as calculating $d'$ or corrected recognition/$P_r$ from hit and false-alarm rates as measures of sensitivity [@SnodgrassAndCorwin1988], or fitting a model to the observed data through maximum likelihood or Bayesian estimation, such as applying the diffusion model to RT and error rates. The distinction between using a simple data transformation versus fitting a model is important and we distinguish the two in Figure \ref{fig:pa}. Many formulae for measuring underlying processes are based on versions of cognitive models with multiple simplifying assumptions, for example fixing several parameters so that equations can be solved. Unfortunately, these simplifying assumptions can make the measure a poor reflection of underlying processes. For example, the simple formula for $d'$ is possible through the 'equal-variance' assumption, which is not well supported by the available evidence [@RatcliffEtAl1992; @morey2008problematic; @Swets1986b]. The consequence of this is that users of $d'$ will often conflate differences in response bias with differences in sensitivity. Measures that were based solely on the raw data, such as proportion correct or mean/median RT, were not considered to relate directly or unambiguously to a hypothetical latent process. 

Figure \ref{fig:pa} (panel a) shows the proportion of studies in *Psychology and Aging* that adopted a measure of an underlying latent process (using the criteria outlined above) between 2011 and 2020. As depicted, this proportion has been relatively low, though it has been rising slightly in more recent years. Nevertheless, it has never been more than around 50% of studies in a given year. Figure \ref{fig:pa} (panel b) shows the proportion of those studies that measured a latent process via a cognitive model fit to data, as opposed to transforming the data using simple equations. Along with the slight increase in studies adopting measures of latent processes there has been a slight increase in the proportion of those studies that are fitting models to data. 

Of the measures of latent processes used, the most common were those attempting to measure sensitivity in two-choice discrimination tasks (e.g., $d'$, hits minus false-alarms or $P_r$) and, of the models fit to data, the unequal variance SDT model described in this tutorial was often used. Table \ref{tab:oth} presents a selective list of the other models used in the articles that fit models along with a brief description and related or competing models.

```{r pa, fig.cap="a: Proportion of cognitive aging studies per year in *Psychology and Aging* in which the dependent variable (DV) was a measure of a latent cognitive process. b: Conditional proportion of studies per year which, given that the DV was a measure of a latent cognitive process, used a cognitive model"}

library(ggplot2)
library(ggpubr)
library(dplyr)
dat <- read.csv("paper/psych_aging_master.csv")
dat.t <- dat %>%
  group_by(Year) %>%
  summarise(no_rows = length(Year), Prop_LatentProcess = mean(measure.of.latent.process),
            Prop_FitModel = mean(fit.model), 
            Prop_FitModel_given_LatentProcess = mean(fit.model[measure.of.latent.process==1])
            #Prop_FitModel_given_LatentProcess = Prop_FitModel/Prop_LatentProcess
            )
dat.t$Year <- factor(dat.t$Year)

#write.csv(dat.t, "psych_aging_tibble.csv")

fig_a <- ggplot(data=dat.t, 
                mapping = aes(x = Year, y = Prop_LatentProcess,
                              group=1)) +
  geom_point() + geom_line() +
  labs(title="DV = Measure of Latent Processes", tag="a") +
  theme_bw() +
  theme(panel.grid.minor=element_blank(),
        panel.grid.major=element_blank(),
        axis.line=element_line(size=0.5, linetype = "solid",
                               color="black")) +
  scale_y_continuous(name="Proportion of Studies", limits=c(0,1.0))

fig_b <- ggplot(data=dat.t, 
                mapping = aes(x = Year, y = Prop_FitModel_given_LatentProcess,
                              group=1)) +
  geom_point() + geom_line() +
  labs(title="Fit a Cognitive Model to Latent Process DV", tag="b") +
  theme_bw() +
  theme(panel.grid.minor=element_blank(),
        panel.grid.major=element_blank(),
        axis.line=element_line(size=0.5, linetype = "solid",
                               color="black")) +
  scale_y_continuous(name="Proportion of Studies", limits=c(0,1.0))

comb <- ggarrange(fig_a, fig_b, ncol=1, nrow=2)
comb

## attempt an analysis
if (F){ # so this doesn't appear in the article
  library(lme4)
  
  table(dat$Article)
  
  dat$Year2 = dat$Year - 2010
  
  m1_lat = glmer(measure.of.latent.process ~ Year2 + (1 | Article), 
                 family = binomial(link = "logit"), data = dat)
  summary(m1_lat)
  
  plot(2011:2020, predict(m1_lat, newdata=data.frame(Year2=1:10),
                          re.form=NA, type="response"), ylim=c(0,.5))
  with(dat.t, points(Year, Prop_LatentProcess, col="red"))
  
  # quadratic
  m2_lat = glmer(measure.of.latent.process ~ poly(I(Year - 2010), 2) + (1 | Article), 
                 family = binomial, data = dat)
  
  summary(m2_lat)
  plot(2011:2020, predict(m2_lat, newdata=data.frame(Year=2011:2020),
                          re.form=NA, type="response"), ylim=c(0,.5))
  with(dat.t, points(Year, Prop_LatentProcess, col="red"))
  
  ## glmer doesn't work (see predictions) because the 
  ## majority of studies were single experiment
  sum(table(dat$Article) == 1) / length(unique(dat$Article))
  
  ### 
  # instead, use glm and ignore (slight) clustering
  m1_lat = glm(measure.of.latent.process ~ Year2, 
               family = binomial(link="logit"), data = dat)
  summary(m1_lat)
  
  # data = red; model = black
  plot(2011:2020, predict(m1_lat, newdata=data.frame(Year2=1:10),
                          type="response"), ylim=c(0,.6))
  with(dat.t, points(as.numeric(as.character(Year)), Prop_LatentProcess, col="red"))
  
  m2_lat = glm(measure.of.latent.process ~ poly(Year2, 2), family = binomial(link="logit"), data = dat)
  summary(m2_lat)
  
  plot(2011:2020, predict(m2_lat, newdata=data.frame(Year2=1:10),
                          type="response"), ylim=c(0,.6))
  with(dat.t, points(as.numeric(as.character(Year)), Prop_LatentProcess, col="red"))
  
  anova(m1_lat, m2_lat, test="Chisq")
  
  # summary: it looks more like the quadratic model (even if p=.06...)
  # both models suggest significant increase in latent measure over time
  
  ## 
  m1_fit = glm(fit.model ~ Year2, family = binomial(link="logit"), 
                data = subset(dat, measure.of.latent.process==1))
  summary(m1_fit)
  
  plot(2011:2020, predict(m1_fit, newdata=data.frame(Year2=1:10),
                          type="response"), ylim=c(0,.6))
  with(dat.t, points(as.numeric(as.character(Year)), Prop_FitModel_given_LatentProcess, col="red"))
   
  m2_fit = glm(fit.model ~ poly(Year2, 2), family = binomial(link="logit"), 
                data = subset(dat, measure.of.latent.process==1))
  summary(m2_fit)
  
  plot(2011:2020, predict(m2_fit, newdata=data.frame(Year2=1:10),
                          type="response"), ylim=c(0,.6))
  with(dat.t, points(as.numeric(as.character(Year)), Prop_FitModel_given_LatentProcess, col="red"))
  
  anova(m1_fit, m2_fit, test="Chisq")
  
  # summary: increase in fitting models given measuring latent process is n.s.
}

```

In summary, while there is increasing interest in cognitive modeling, it clearly remains the exception, rather than the norm, in cognitive aging research.[^empir] This may be due to a lack of model development in particular domains (i.e., there may be no established models to choose from) as well as a lack of accessible resources for researchers wanting to apply modeling in their own work. This tutorial will hopefully serve as a starting point for cognitive aging researchers interested in cognitive modeling, and the increasing accessibility of this topic will hopefully lead to a proliferation of new models into domains where process models are lacking [see @van2020formalizing for a tutorial on formalizing theory]. In the next section, we describe how to fit a SDT account of data from a two-choice discrimination task with a focus on testing age differences in underlying parameters. Specifically, we describe how to implement these as hierarchical models that simultaneously model individual participant and group level effects.

[^empir]: This is not to say that work involving cognitive modeling is the only work of importance or that we would like to see 100% of work adopting such an approach; research identifying robust and replicable behavioral phenomenon is crucial and provides the evidence base for developing models of cognition.

```{r, results="asis"}

# library(papaja)
# library(knitr)
# library(kableExtra)

other_tab = read.csv("paper/other-models-table.csv")

#kable(other_tab, format = "markdown", booktabs=T)

strCaption <- paste0("Selected models that were also used in papers identified by our review of Psychology and Aging between 2011 and 2020. The references and related/competing models are not exhaustive.")

cat("\\begin{landscape}")
print(xtable(other_tab, caption = strCaption, label = 'tab:oth', 
             align = c("p{0.0\\textwidth}",
                       "p{0.2\\textwidth}",
                       "p{1\\textwidth}",
                       "p{0.30\\textwidth}",
                       "p{0.50\\textwidth}")), caption.placement = 'top', hline.after = NULL, include.colnames = F, include.rownames = F, sanitize.text.function = force, floating=TRUE, table.placement = 't', comment=F, scalebox = .65, add.to.row = list(pos = list(-1, nrow(other_tab)),       command = c(paste0("\\toprule \n", "Model & Brief description & References & Related/competing models\\\\\n","\\midrule \n"), paste0("\\bottomrule \\\\\ "))))
cat("\\end{landscape}")

```

# Tutorial: Modeling Age Differences in Choice Discrimination

## Description of the model

SDT [@GreenAndSwets1966; @TannerAndSwets1954] provides a framework to understand performance in various situations where the objective is to discriminate signal from noise [see @MacmillanAndCreelman2005 for a comprehensive introduction]. One of the most commonly used tasks in cognitive aging studies is the yes-no experiment, in which participants must decide whether a particular trial contains signal (e.g., a previously seen stimulus, the presence of a particular target stimulus) or just noise (e.g., a new stimulus, a non-target). 

To model this situation (and others), SDT assumes that each trial elicits a particular value along what is called the 'decision variable'; on average, signal trials produce larger values, but, due to internal and/or external noise, the distribution of values for signal and noise trials will often overlap (which makes the discrimination imperfect). The distance between the central tendencies of these two distributions is an index of 'discriminability' (or sensitivity).

In the simple yes-no case, a plausible assumption is that participants use a 'criterion' to make the decision. If the value on the decision variable on a particular trial is above the criterion the response will be *yes* (i.e., signal), otherwise the response will be *no*. The familiar measures $d'$ and $c$ come from a particular implementation of SDT in which the underlying signal/noise distributions are assumed to be normal with equal width. As noted above, this 'equal-variance' assumption has been a particular source of controversy [@RatcliffEtAl1992; @Swets1986b; @Swets1986a]; however, in order to verify this assumption more information is needed beyond the binary yes-no decision.

One additional source of information is to ask the participant to provide a more fine grained discrimination in which they provide their level of confidence in the presence or absence of signal. This can be done with a likert-type scale ranging from sure-no to sure-yes or by first asking for an yes-no decision before asking for a level of confidence [@YonelinasAndParks2007]. To model this, we can assume that, instead of one criterion, the observer establishes $K - 1$ criteria, where $K$ is the number of options. Figure \ref{fig:sdt} (top panel) gives a visual depiction of this model where $d$ is the difference between the means of the noise and signal distributions and $s$ is the standard deviation of the signal distribution. The standard deviation of the noise distribution is fixed to 1 to provide scale (note: the exact values of the decision variable are arbitrary).

```{r sdt, fig.cap="Top: A signal detection model for a rating experiment in which there are 6 options (1 = 'sure no signal', 6 = 'sure signal'). The observer is assumed to use 5 criteria and the rating chosen on a particular trial is determined by the sampled value on the decision variable (e.g., a rating of 4 would be given if the sampled value falls between thresholds 3 and 4). Bottom left: Expected proportion that each rating would be selected for noise and signal trials under the model depicted in the top panel. The proportions are determined by finding the area under the noise/signal curves between the respective criteria. Bottom right: The reciever operating characteristic (ROC) curve implied by the model. Hits are calculated by taking the cumulative sum of the response proportions on signal trials, starting at 'sure signal' (i.e., rating 6). False-alarms are calculated similarly but using noise trials. The furthest left point is the response proportions for ratings of 6, the next point sums the proportions across ratings of 5 and 6, and so on. The last point is not presented as it must be (1,1)."}

ps = c(2, 1.2, 1, .5, 6)

# layout(mat = cbind(c(1,1), c(1,1), c(2,3)))
layout(mat = rbind(c(1,1), c(2,3)), heights = c(1.5, 1))

# model plot
plotSDT(d = ps[1], s = ps[2], a = ps[3], b = ps[4], C = ps[5], allpars = T)

# proportions
noi_pch = 1; sig_pch = 2
noi_col = "black"; sig_col = "darkgrey"
par(pty='m', mar=c(4,4,.5,.5))
x=ratingModel(d = ps[1], s = ps[2], a = ps[3], b = ps[4], C = ps[5])
plot(x[,1], pch=noi_pch, col=noi_col, type="b", 
     ylim=c(0,max(x)*1.2), xlab = "Rating", ylab="p(rating | trial type)") # noise
points(x[,2], pch=sig_pch, col=sig_col, type="b") # signal

text(x = 2, y = x[2,1], labels = "noise", adj = c(1.1,-.5), col = noi_col)
text(x = 5, y = x[5,2], labels = "signal", adj = c(1.1,-.5), col = sig_col)

# roc
par(pty='s', mar=c(2,2,.5,.5))
plot(ratingModel(d = ps[1], s = ps[2], a = ps[3], b = ps[4], C = 1000, ratingProbs = F),
     ylim=c(0,1), xlim=c(0,1), type='l', axes=F, xlab="", ylab="")
#xlab='false-alarm rate', ylab='hit rate')
box()
axis(1, at=c(0,1))
axis(2, at=c(0,1))
a = ratingModel(d = ps[1], s = ps[2], a = ps[3], b = ps[4], C = ps[5], ratingProbs = F, lastPoint=F)
points(a, ylim=c(0,1), xlim=c(0,1), pch=21, bg='grey')

mtext("false-alarms", 1, line = 1)
mtext("hits", 2, line = 1)

text(t(t(a)+c(.08,-.08)), labels = 
       as.expression(unlist(lapply(X = 5:1, function(x) bquote(c[.(x)])))))

```

Under this model, the probability that the observer gives a particular rating is given by the area under the noise or signal distributions that falls in-between the relevant criteria. For example, for rating 3 it is the area between criteria 2 and 3 ($c_2$ and $c_3$). Assuming the underlying distributions are normal we can use:
$$
\begin{aligned}
p(\mbox{rating} = k \mid \mbox{noise}) = \Phi(-c_{k}) - \Phi(-c_{k - 1}) \\
p(\mbox{rating} = k \mid \mbox{signal}) = \Phi{\left( \frac{d - c_{k}}{s} \right)} - \Phi{\left( \frac{d -c_{k - 1}}{s} \right)}
\end{aligned}
$$
where $c_0 = -\infty$, $c_K = \infty$, and $\Phi$ is the standard normal cumulative distribution function (`pnorm` in `R`). Predicted rating probabilities are given in the bottom left of Figure \ref{fig:sdt} along with the receiver operating characteristic (ROC) curve in the bottom right.

The parameters of the SDT model shown in Figure \ref{fig:sdt} are $d$, $s$, and the criteria $c_{1,...,K-1}$. This means that using a task with more response categories requires more parameters to fit. Recently, @selker2019parsimonious have proposed a more parsimonious version of the model in which, instead of having separate parameters for each criterion, we start with unbiased criteria ($u$) that are then scaled ($a$) and shifted ($b$) by two free parameters:
$$
\begin{aligned}
u_k = \log\left( \frac{k/K}{1 - k/K} \right) = \mbox{Logit}(k/K) \\
c_k = au_k + b.
\end{aligned}
$$

Higher values of $a$ spread the criteria further apart, whereas higher values of $b$ shift the criteria to the right (more conservative).

## Implementing the model

Figure \ref{fig:sdt} shows the situation where $d = `r ps[1]`$, $s = `r ps[2]`$, $a = `r ps[3]`$, and $b = `r ps[4]`$. However, these parameters likely vary across participants (differing both between young and older adults, but also within each age group) as well as with experimental manipulation. We could fit the model to each individual participant separately (e.g., via maximum likelihood), but, for the reasons outlined above, our preferred approach is to model both group- and individual-level effects simultaneously in a Bayesian hierarchical model. In this tutorial we outline how to implement the SDT model in the probabilistic programming language, Stan [https://mc-stan.org/; @carpenter2017stan], which performs the MCMC sampling often required in fitting models under a Bayesian framework. Documentation and tutorials on the Stan language can be found here: https://mc-stan.org/users/documentation/tutorials. Stan can be used in conjunction with other software, such as Python, Matlab, and Stata (https://mc-stan.org/users/interfaces/), but here we will be using `R` [@rteam] and the `rstan` package [@rstan] as our interface (see the additional material[^suppl] for more information on installing the relevant software). Thus, while familiarity with `R` will be helpful, the tutorial on writing Stan models will hopefully be of use to users of other analysis software.[^R] Next we will go through a series of questions that we need to address to set up a working Stan implementation of the (hierarchical) SDT model.

[^suppl]: The additional material is available here: https://github.com/stephenrho/cognitive-aging-modeling/blob/master/paper/cognitive-modeling-supplement.pdf

[^R]: We encourage readers to download the materials accompanying this article from https://github.com/stephenrho/cognitive-aging-modeling and use the `fit_SDT.R` script to follow the analyses described here. As the models can take a long time to fit, fitted models can also be downloaded by following instructions at the link above.

### How are the data organized?

To write the model we need a clear understanding of the structure of the data. Here we will be working with simulated data from a rating experiment in which young and old adult participants ($N=24$ each group) rated their confidence in the presence of a signal on a scale from 1 to 6. The following `R` code allows us to see the first 6 rows (`##` signals output from `R`):

```{r, echo=T}
rdat = read.csv("data/example-data.csv") # load the data into R
head(rdat) # show the first 6 rows
```

The format of these data is referred to as long (or tall), where a single observation is recorded on each row. Each row represents a trial where `id` is a participant identifier, `group` signals whether the participant is younger (Y) or older (O), `signal` codes for whether the trial was noise (0) or signal (1), and `rating` is the response. The variable `cond` codes for an additional factor of condition with two levels (A, B; 40 observations each), which we include here to demonstrate how to test for interactions between age and other variables, which are common in the cognitive aging literature. As a concrete example, this could be thought of as data from a recognition memory experiment where old items are considered the signal and unstudied new items are noise and each participant rated their degree of memory for particular items (from sure-new to sure-old) under two conditions (e.g., a levels of processing manipulation).

With this data in mind we can start to write the Stan model, which can be found in the file `SDT_m1.stan` (available at https://github.com/stephenrho/cognitive-aging-modeling). Stan models are made up of 'blocks' (https://mc-stan.org/docs/2_27/reference-manual/overview-of-stans-program-blocks.html) and usually start by declaring the data. The Stan code below specifies the data necessary to fit the SDT model (the comments, following `//`, describe each line and are ignored by Stan).

```
data {
  int<lower=0> N;               // n observations
  int y[N];                     // ratings
  int<lower=0> J;               // n participants
  int<lower=1,upper=J> id[N];   // participant ids
  matrix[N, 2] X;               // design matrix for fixed (group-level) effects
  vector[N] sig_trial;          // indicator for signal (1) or noise (0) trial
  int<lower=2> K;               // n categories
}
```

The `data` block specifies the type, dimensions, and, where appropriate, range of each object. For the design matrix, `X`, which codes the group-level effects, there are two columns as the first is the intercept term (1 for all observations) and the second column codes age-group. Table \ref{tab:syn} provides a simple explanation of snippets of Stan code used in this example to supplement the explanation in the text. It is important to note that, as we are building the model from the ground up, we could have structured the data differently. However, the exact way in which the model is written below would be different for a different data structure so it is important to consider this when writing the data block.

```{r, results="asis"}

syn_tab = read.csv("paper/syntax-table.csv")

# column_spec(knitr::kable(syn_tab, format = "latex", booktabs=T), c(1,2), width = c("5cm", "10cm"))

strCaption <- paste0("Selected parts of the Stan syntax used in the present example with a brief explanation")

print(xtable(syn_tab, caption = strCaption, label = 'tab:syn', 
             align = c("p{0.0\\textwidth}",
                       "p{0.40\\textwidth}",
                       "p{0.80\\textwidth}")), caption.placement = 'top', hline.after = NULL, include.colnames = F, include.rownames = F, sanitize.text.function = function(x) x, floating=TRUE, table.placement = '!h', comment=F, scalebox = .7, add.to.row = list(pos = list(-1, nrow(syn_tab)),       command = c(paste0("\\toprule \n", "Syntax &  Explanation\\\\\n","\\midrule \n"), paste0("\\bottomrule \\\\\ "))))

```

Next, in fitting the @selker2019parsimonious version of the model, we use the number of categories, $K$, to create the unbiased criteria that the model will shift and scale. We use a `transformed data` block to do this:
```
transformed data {
  vector[K-1] unb_c;
  for (k in 1:(K-1)){
    unb_c[k] = -log( (1 - (exp(log(k) - log(K))))/(exp(log(k) - log(K))) );
  }
}
```

The first line creates the vector, `unb_c`, to hold the `K-1` unbiased criteria, and the `for` loop populates it. The expression for the criteria may look odd compared to the formula above and Table \ref{tab:syn} (bottom row) provides an explanation.

### What are the model parameters?

The parameters of the signal detection model are $d$, $s$, $a$ and $b$ (where the latter two determine the criteria $c_{1}, \ldots, c_{K-1}$). However, in fitting the model hierarchically there are additional parameters we need to think of. Specifically, we need to think of the group-level and individual-level effects on the SDT parameters. Taking $d$ as an example, we can model $d$ for each individual, $j$, as,
$$
\begin{aligned}
d_{j} = \beta^{(d)} + b^{(d)}_{j} \\
b^{(d)}_{j} \sim \mbox{Normal}(0, \; \tau^{(d)}),
\end{aligned}
$$
where there are two parts: the group average, $\beta^{(d)}$, and individual deviations from that average, $b^{(d)}_{j}$, that are assumed to be normally distributed with standard deviation, $\tau^{(d)}$. An alternative way of writing this, which better captures the idea that the $d$s come from a 'population' distribution is, $d_j \sim \mbox{Normal}(\beta^{(d)}, \; \tau^{(d)})$. The $\sim$ (tilde symbol) means "is distributed as" and is also used by Stan to denote variables with a distribution (see Table \ref{tab:syn}).

As cognitive aging researchers we can extend this to model age differences in $d$ by including an additional group-level effect:
$$
d_{j} = \beta_{0}^{(d)} + \beta_{1}^{(d)}x_j + b^{(d)}_{j},
$$
where $x_j$ codes the age group of individual $j$, and $\beta_{1}^{(d)}$ is the coefficient giving the difference between groups. Thus, there are 3 parameters related to $d$ that we estimate directly: $\beta_{0}^{(d)}$, $\beta_{1}^{(d)}$, and $\tau^{(d)}$. The individual $b^{(d)}_{j}$s are estimated indirectly and depend on $\tau^{(d)}$. In a highly flexible model we might apply the same approach to the other SDT parameters to account for all possible sources of age difference, and this is what we do in the example below.

In Stan the `parameters` are specified in their own block, as follows:
```
parameters {
  // d
  vector[2] B_d;
  real b_d[J];
  real<lower=0> tau_d;
  
  // c (shift [b] and scale [a])
  vector[2] B_a;
  real b_a[J];
  real<lower=0> tau_a;
  
  vector[2] B_b;
  real b_b[J];
  real<lower=0> tau_b;

  // s
  vector[2] B_s;
  real b_s[J];
  real<lower=0> tau_s;
}
```
where uppercase `B`s are the $\beta$s and lowercase `b`s are the $b$s and the letter after the underscore refers to the corresponding SDT parameter. In writing the model we specify the $\beta$ parameters as vectors, instead of specifying them separately as in the equations above; this approach easily scales to include more predictors, as we demonstrate below in the section "Extending the model". 

Next we can use a `transformed parameters` block to map these parameters onto the trial level values of $d$, $s$, $a$, and $b$. However, before we do this, we have to address a remaining issue in relating the hierarchical parameters to the parameters of the SDT model. Specifically, the SDT parameters $d$, $s$, and $a$ are *constrained* to be positive [see @paulewicz2020bhsdtr for rationale on why $d$ should be positive]. However, adding the normally distributed individual-level effects to the population means allows for negative values. Thus, for constrained parameters we need a *link function* to map the hierarchical parameters onto the SDT parameters (this will be familiar to users of generalized linear models). For positively constrained parameters a common choice is to have the hierarchical parameters (the $\beta$s, $b$s, and $\tau$s) be on the log scale, where the exponential function is the link that maps these to their natural scale. So taking the example of $d$ again we modify the above equation to:
$$
d_{j} = \exp\left(\beta_{0}^{(d)} + \beta_{1}^{(d)}x_j + b^{(d)}_{j}\right).
$$

The `transformed parameters` block starts by creating vectors to hold the SDT parameters for each observation, $1,\ldots,N$ (we will discuss `theta` later). The `for` loop then goes through the $N$ observations and uses the value of the predictors contained in `X` and the participant `id`s to set things for observation $i$. This requires the use of indexing (see Table \ref{tab:syn}): `X[i,]` selects row `i` of the design matrix and this is used to calculate the dot product with the group level parameters (i.e., $\beta_0 + \beta_1x_i$); `b_d[id[i]]` first finds the participant `id` associated with observation $i$ and uses this to index the individual-level parameter associated with that participant [sometimes written $b_{j[i]}$; e.g., @GelmanAndHill2007].

```
transformed parameters {
  real<lower=0> d[N]; // note that d, a, and s are constrained positive
  real<lower=0> a[N]; 
  real b[N];
  real<lower=0> s[N];
  vector[K-1] c[N];
  
  simplex[K] theta[N];

  for (i in 1:N){
    // observation level parameters
    d[i] = exp( dot_product(X[i,], B_d) +  b_d[id[i]] );
    a[i] = exp( dot_product(X[i,], B_a) + b_a[id[i]] );
    b[i] = dot_product(X[i,], B_b) + b_b[id[i]];
    s[i] = exp( dot_product(X[i,], B_s) + b_s[id[i]] );
    
    c[i] = a[i]*unb_c + b[i];

    ... // continued below
```

### How do the parameters relate to predictions for each observation?

As we have specified the values of the SDT parameters for each observation, we are now ready to use them to produce predicted ratings, which is done in the second part of the `transformed parameters` block:

```
    ... // continued from above

    // rating probabilities under SDT
    if (sig_trial[i] == 1){ // signal trial
      theta[i,1] = normal_cdf(c[i,1], d[i], s[i]);
      for (k in 2:(K-1)){
        theta[i,k] = normal_cdf(c[i,k], d[i], s[i]) - sum(theta[i,1:(k-1)]);
      }
    }
    else { // noise trial
      theta[i,1] = normal_cdf(c[i,1], 0, 1);
      for (k in 2:(K-1)){
        theta[i,k] = normal_cdf(c[i,k], 0, 1) - sum(theta[i,1:(k-1)]);
      }
    }
    theta[i,K] = 1 - sum(theta[i,1:(K-1)]); // last rating probability 
  }
}
```

While it looks somewhat complicated, this implements the first two equations presented above to produce predicted probabilities for the $1,\ldots,K$ rating categories. If observation `i` comes from a signal trial (i.e., `sig_trial[i] == 1` is `TRUE`) the response probabilities come from a normal distribution with a mean of `d` and a standard deviation of `s`, otherwise they come from the noise normal distribution, which has a mean of 0 and a standard deviation of 1. The object `theta` contains the predicted ratings for each observation in the data set (each `theta[i,]` is defined as a 'unit simplex' at the beginning of this block, which means the values must sum to 1). 

### How do we relate the predictions to the data?

The `model` block brings everything together and serves two main purposes: (1) to specify the prior distribution for the model parameters and (2) to specify the likelihood function that expresses the likelihood of the observed data given the model parameters. These things form the basis of Bayesian estimation, where the posterior distribution is proportional to the prior $\times$ the likelihood. Prior distributions reflect the degree of belief in particular parameter values before seeing new data, and further detail on the particular settings used below is given in the [additional material](https://github.com/stephenrho/cognitive-aging-modeling/blob/master/paper/cognitive-modeling-supplement.pdf).

```
model {
  // priors
  B_d[1] ~ normal(0, 1);
  B_d[2] ~ normal(0, 0.5);
  B_a[1] ~ normal(0, 1);
  B_a[2] ~ normal(0, 0.5);
  B_b[1] ~ normal(0, 2);
  B_b[2] ~ normal(0, 1);
  B_s[1] ~ normal(0, 0.5);
  B_s[2] ~ normal(0, 0.25);

  tau_d ~ cauchy(0, 1);
  tau_a ~ cauchy(0, 1);
  tau_b ~ cauchy(0, 2);
  tau_s ~ cauchy(0, 0.5);

  // individual-level deviations
  b_d ~ normal(0, tau_d);
  b_a ~ normal(0, tau_a);
  b_b ~ normal(0, tau_b);
  b_s ~ normal(0, tau_s);

  // likelihood
  for (i in 1:N){
    y[i] ~ categorical(theta[i]);
  }
}
```

The line `b_d ~ normal(0, tau_d);` captures the assumption that individual deviations from the group mean follow a normal distribution centered on zero with a standard deviation of `tau_d` (similarly for the other SDT parameters). Finally, the line `y[i] ~ categorical(theta[i]);` expresses the assumption that the response on trial $i$ comes from (or is distributed as) a categorical distribution with the probabilities of the $K$ categories set by `theta`, which we created in the block above. 

## Fitting the model

With the Stan model written and saved in a `.stan` file we can now switch to `R` to fit the model. The `rstan` package takes data in list form, so we need to extract the relevant information from the data set that we read into `R` earlier (saved in the object, `rdat`). Here we need to recall what names we use in the `data` block of the Stan model and match these to the list items in `R`:

```{r, echo=T}
data_list = list(
  N = nrow(rdat), # number of observations (trials)
  y = rdat$rating, # response
  J = length(unique(rdat$id)), # number of participants
  id = rdat$id, # participant ids
  X = model.matrix(~ 1 + group, data = rdat), # predictors
  sig_trial = rdat$signal, # was this a signal trial? (1 = yes, 0 = no) 
  K = 6 # number of rating categories
)
```

`data_list` now contains everything we need. The `stan` function does the work of fitting the model:

```{r, eval=F, echo=T}
library(rstan)

SDT_m1_fit <- stan(
  file = "models/SDT_m1.stan", # the stan model (from a separate file)
  data = data_list, # the list created above
  chains = 4, # run 4 separate chains to assess convergence
  warmup = 1000, # these are used to tune the sampler and 'burn in'
  iter = 2000, # number of iterations (#kept = chains*(iter - warmup))
  cores = 4 # chains can be run in parallel on separate cores (if possible)
)
```

```{r, messages=F, warning=F, results="hide"}
# read saved model files

SDT_m1_fit = readRDS("models/SDT_m1_fit.rds")

yrep <- extract(SDT_m1_fit, pars = "y_rep")[[1]]
y <- rdat$rating

yrep = yrep[sample(1:nrow(yrep), size = 500),]

age_d = extract(SDT_m1_fit, pars="B_d[2]")[[1]]
```

Once the sampling is complete the `SDT_m1_fit` object contains posterior samples of the model parameters. To assess whether the sampler has converged on a stable posterior distribution, we can compare variability within chains to that between [using the $\hat{R}$ statistic discussed in @GelmanEtAl2014 pp. 284--286]. Discussion of other warning messages that may be produced by Stan and ways to resolve them is beyond the present scope (see https://mc-stan.org/misc/warnings.html).

### Does the model do a good job?

It is important to assess whether the fitted model provides an accurate representation of the observed data. One way of doing this is by plotting data simulated from the fitted model (posterior predictions) against the observed data. This requires that we add an extra block, `generated quantities`, to our Stan model, and this is covered in the [additional material](https://github.com/stephenrho/cognitive-aging-modeling/blob/master/paper/cognitive-modeling-supplement.pdf).

### Assessing age differences in model parameters

We can extract samples for parameters of interest. In particular, we are interested in $\beta^{(d)}_1$ which is the coefficient associated with age differences in sensitivity. The code below extracts the samples for this parameter and plots a histogram.

```{r, echo=T, eval=F}
age_d = extract(SDT_m1_fit, pars="B_d[2]")[[1]] # extract the age effect on d
```

```{r, echo=T, fig.cap="Histogram of posterior samples for the hiearchical parameter estimating age differences in $d$ (on the transformed/log scale)."}
# plot a histogram
hist(age_d, breaks=20, xlab="", main=bquote(Beta[1]^'(d)'), probability = T)
```

Do the groups differ in sensitivity? Assuming we have converged onto a stable distribution, parameter values will appear in the samples in proportion to their density under the posterior distribution. This means we can make statements like, 'there is a 95% chance that the true difference between groups falls in this interval' [which is not the case for standard confidence intervals; @HoekstraEtAl2014]. 

In the `R` code and output below we extract the posterior mean and median as well as measures on uncertainty: 95% credible (CI) and highest density (HDI) intervals. The CI is based on quantiles of the posterior samples whereas the HDI is the shortest interval that contains X% of the posterior samples [see @Kruschke2015 for details on interpretation]. 

```{r, echo=T}
# posterior mean
mean(age_d)

# median and 95% credible interval
quantile(age_d, probs = c(0.025, .5, 0.975)) 

# 95% highest density interval
library(HDInterval)
hdi(age_d, credMass = .95)

```

Thus, our best estimate of the group difference in $\log(d)$ is `r round(mean(age_d) ,2)` and we cannot confidently rule out values of between `r round(hdi(age_d, credMass = .95)[[1]], 2)` and `r round(hdi(age_d, credMass = .95)[[2]], 2)` (95% HDI). It may be more intuitive to convert difference back to the natural scale of $d$. This is done in the code below:
```{r, echo=T}
# extract the group-level effects for d
B_d = extract(SDT_m1_fit, pars="B_d")[[1]]
# column 1 of B_d is the intercept and column 2 is the age difference
# the younger group is the intercept as they were coded zero

d_young = exp( B_d[,1] ) # transform back to natural scale
d_old = exp( B_d[,1] + B_d[,2] )

hdi(d_young)
hdi(d_old)

hdi(d_young - d_old) # HDI for the group difference
```

The 95% HDI for the difference in $d$ between the younger and older groups is [`r round(hdi(d_young - d_old, credMass = .95)[[1]], 2)`, `r round(hdi(d_young - d_old, credMass = .95)[[2]], 2)`]. 

## Extending the model

The first model can be extended in multiple ways. For example, if we wanted to evaluate the weight of evidence in favor an age difference in $d$ we could construct a second model in which this parameter is fixed across groups (this model is written in the `SDT_m2.stan` file) to compare to the first model. The [additional material](https://github.com/stephenrho/cognitive-aging-modeling/blob/master/paper/cognitive-modeling-supplement.pdf) covers model comparison using the `bridgesampling` package [@bridgesampling] to calculate Bayes' factors. It also covers the inclusion of item/stimulus effects, which are often an important source of variability in performance and are important to take into account for accurate estimation (see "Why Use Hierarchical Bayesian Estimation?"), and how to model differences in between-participant variability between different age groups [@shammi1998aging]. In addition, it describes how to utilize the information on individual differences in latent cognitive parameters and how to extend the model to correlate this with other measures of interest (e.g., neuropsychological scores, personality assessments, biological variables).

The extension we want to cover here goes beyond asking whether there are age differences in certain parameters (we will focus again on $d$) to ask whether group differences are modulated by experimental manipulation (tests of group $\times$ condition interaction). In the example data set there is the additional factor of `cond` and each participant provides observations in both conditions (i.e., repeated measures). Therefore, we can model individual differences in the effect of condition. To extend the model (see `SDT_m3.stan`) we also must expand the `data` block of the model to change the design matrix, `X`, for the population-level effects and introduce a design matrix, `Z`, for individual-level effects:

```
  matrix[N, 4] X;   // design matrix for fixed (group-level) effects
  matrix[N, 2] Z;   // design matrix for random (individual-level) effects
```

In `R` we also modify the `data_list` so that `X` codes for main effects of group and condition plus their interaction and `Z` codes for the main effect of condition (including an individual-level effect of group here would not make sense, as each individual can only belong to one group).

```{r, echo=T}
data_list$X = model.matrix(~ 1 + group + cond + group:cond, data = rdat)
data_list$Z = model.matrix(~ 1 + cond, data = rdat)
```

The `parameters` block must also be modified to reflect that there are now 4 group level effects and 2 individual effects, for which we are also modeling the correlation. Estimating the correlation allows us to assess whether participants with greater discriminability overall (captured by the intercept) exhibit a larger or smaller condition effect.

```
  // d
  vector[4] B_d; // 4 population effects (intercept, group, condition, interaction)
  vector[2] b_d[J]; // 2 individual effects (intercept, condition)
  corr_matrix[2] Sigma_d; // correlation of individual effects
  vector<lower=0>[2] tau_d; // SD of individual effects
```

In the `transformed parameters` block the main modification is to the line determining $d$ to reflect the combination of the group- and individual-level parameters. In addition, the lines for the other parameters are modified so that only the first two columns of the design matrix (`X[i,1:2]`) are used, as we are only modeling the main effect of age group for these parameters (although notice that it would be easy to modify to relax this assumption):

```
  d[i] = exp( dot_product(X[i,], B_d) + dot_product(Z[i,], b_d[id[i]]) );
  a[i] = exp( dot_product(X[i,1:2], B_a) + b_a[id[i]] );
  b[i] = dot_product(X[i,1:2], B_b) + b_b[id[i]];
  s[i] = exp( dot_product(X[i,1:2], B_s) + b_s[id[i]] );
```

Finally, in the `model` block we must modify the way in which individual-level parameters for $d$ are determined. The first line specifies the prior distribution for the correlation matrix `Sigma_d` and the subsequent lines loop through the participants and sample their parameters from a zero-centered multivariate normal distribution (the `quad_form_diag` function creates a covariance matrix). 

```
  Sigma_d ~ lkj_corr(1.0);

  // sample individual coefficients
  for (j in 1:J){
    b_d[j] ~ multi_normal([0,0], quad_form_diag(Sigma_d, tau_d));
  }
```

The line `Sigma_d ~ lkj_corr(1.0);` specifies an 'LKJ' prior [@lewandowski2009generating] on the correlation matrix for the individual-level $d$ effects (i.e., the participant intercept and effect of condition). The setting of 1 means that all correlations (-1 to 1) are equally likely before seeing the data. More information on specifying multivariate priors can be found at https://mc-stan.org/docs/2_27/stan-users-guide/multivariate-hierarchical-priors-section.html.

With these modifications we are ready to fit this model with `rstan`:

```{r, eval=F, echo=T}
SDT_m3_fit <- stan(
  file = "models/SDT_m3.stan",
  data = data_list,
  chains = 4,
  warmup = 1000,
  iter = 2000,
  cores = 4
)
```

The [additional material](https://github.com/stephenrho/cognitive-aging-modeling/blob/master/paper/cognitive-modeling-supplement.pdf) shows how to use this fitted model to calculate differences between groups and conditions.

# Discussion

Cognitive models formalize the relationship between latent processes and observed behavior and, therefore, get cognitive aging researchers closer to measuring what they are interested in. Fitting these models as hierarchical Bayesian models allows one to take into account multiple sources of variability (e.g., participant, item), leading to more accurate estimation of age differences in cognitive processes.

In this tutorial, we have laid out how to model age differences in the cognitive processes that are theorized to underlie task performance. We have done so with an example of a choice discrimination task, given that this is one of the most commonly encountered paradigms in the study of cognitive aging, and with models inspired by signal detection theory, as these represent some of the most popular cognitive models. Nevertheless, the approach we have outlined here can be applied broadly to other models and other tasks of cognition.[^ex] For example, researchers interested in measuring age differences in working memory capacity can easily adopt the current approach to implement these MPT models [e.g., @RouderEtAl2011; and see @RhodesEtAl2018; @GreeneEtAl2020 for applications of hierarchical versions of such models with age comparisons]. We provide extensions of the modeling techniques reported here in the [additional material](https://github.com/stephenrho/cognitive-aging-modeling/blob/master/paper/cognitive-modeling-supplement.pdf), where we also discuss how to use MPT models with an example of @BroderEtAl2013's ratings model. 

[^ex]: More examples of cognitive models written in Stan are available at: https://github.com/stan-dev/example-models/tree/master/Bayesian_Cognitive_Modeling

As cognitive aging researchers are primarily interested in understanding how cognitive processes change across the adult lifespan, cognitive models are better suited to measuring these theorized processes than are traditional methods (e.g., ANOVA) applied to the raw or aggregated data (e.g., accuracy, mean RT). Of course, as with any statistical model, a cognitive model is merely an approximation of reality. Researchers must be aware of limitations of cognitive models before using them. For example, although cognitive models are useful for deriving estimates for parameters corresponding to theorized processes, these estimates cannot, strictly speaking, indicate whether a theorized process truly exists, as all cognitive processes are unobservable by nature. Also, many cognitive models have been designed and validated for specific tasks, and such models are not suitable for measuring some other phenomena. 

Widespread use of cognitive modeling in cognitive aging research can be useful for addressing potential issues of non-replicability in the field. Because many studies in cognitive aging only rely on analyses applied to the raw data (as our survey of the last ten years of articles in *Psychology and Aging* indicates), these studies risk making conclusions that do not hold at the level of latent processes [@RotelloEtAl2015; @RotelloEtAl2008; @rhodes2019interaction]. Accordingly, these studies risk over- or under-estimating the amount of age-related change that occurs to specific cognitive processes (e.g., memory strength). Relatedly, such studies may lead to a mistaken literature of age differences in cognitive processes that are based on analyses that conflate processes [in this case replication would only serve to compound the error; @RotelloEtAl2015]. Implementing models under the Bayesian framework comes with several notable benefits when it comes to assessing model adequacy and, therefore, the veracity of claims that can be made from a model based analysis. These include principled workflows that allow one to identify areas of model misspecification [@schad2021toward], methods for assessing out-of-sample predictive accuracy [e.g., @VehtariEtAl2017], and a means of quantifying the relative evidence in favor of competing models of age-related differences in cognition (i.e., Bayes factors; see [additional material](https://github.com/stephenrho/cognitive-aging-modeling/blob/master/paper/cognitive-modeling-supplement.pdf) for an example). 
<!--
In addition, cognitive models are better suited to ascertaining whether there is evidence for or against an age difference, especially under a Bayesian estimation framework, as credible intervals and/or HDIs convey the most probable values of a parameter. Accordingly, it is more straightforward to infer if two groups (e.g., young and older adults) differ on a parameter by comparing whether 0 is extreme relative to the HDI than is possible under a frequentist framework. As evidence for null effects may of particular interest to cognitive aging researchers, the ability to quantify such evidence, for example via Bayes factors (see [additional material](https://github.com/stephenrho/cognitive-aging-modeling/blob/master/paper/cognitive-modeling-supplement.pdf)), should be a powerful asset for cognitive aging researchers.
-->

## Further Readings

This tutorial is intended to serve as one important learning tool for cognitive aging researchers as they begin to embark on their own cognitive modeling journeys. However, there are certainly other resources to consult, and learning cognitive modeling requires time, patience, and dedication. For lengthier reads about cognitive modeling in general (though not with specific applications in aging, per se), we recommend the great books by @lee2014bayesian and @FarrellAndLewandowsky2018. There are many highly accessible books for learning Bayesian statistics, including @Kruschke2015 and @McElreath2016 [see @EtzEtAl2018 for an annotated reading list]. Finally, there are many great articles published in the first issue of the 2011 volume of *Journal of Mathematical Psychology* on hierarchical Bayesian estimation in general, with specific applications in cognitive modeling, including @lee2011cognitive. Several more recent articles on the topic of cognitive modeling were published in the December 2019 issue of *Computational Brain & Behavior*, which featured a lengthy discussion among several top cognitive modelers on the topic of robust modeling in cognitive science [@LeeEtAl2019] and other best practices in cognitive modeling, including whether cognitive models should be pre-registered [@MacEachernAndVanZandt2019]. 

Finally, recent proposals for a Bayesian workflow when fitting cognitive models can be found in @schad2021toward. This covers important steps that researchers can take to ensure the robustness and replicabilty of their analyses, including the specifiction of priors, diagnostic checks of model adequacy (e.g., model recovery simulations), convergence, and fit, and posterior predictive checks of the model, using simulations from the model's posterior distribution.

<!--Cognitive modeling is an ever-evolving field. Therefore, it is important that cognitive modelers keep as up-to-date as possible with new advances and recommended practices. In this tutorial, we focused on hierarchical Bayesian estimation of cognitive models, as estimation under a hierarchical Bayesian framework is suitable for addressing both individual- and group-level effects simultaneously and is a powerful technique for non-linear modeling. Bayesian analyses are often more robust than frequentist equivalents and are suitable for quantifiying uncertainty about cognitive parameters, and models in general [@WagenmakersEtAl2016]. When adopting a Bayesian analytical approach for cognitive modeling, researchers should carefully consider the choice of prior specification of model parameters. Researchers also should conduct diagnostic checks of model adequacy (e.g., model recovery simulations), convergence, and fit, and posterior predictive checks of the model, using simulations from the model's posterior distribution [for a more detailed discussion, including a recommended work-flow, see @schad2021toward]. In addition, it is often necessary to compare multiple models, and such comparisons can be made in a Bayesian framework with a Bayes factor approach, though researchers should be mindful of the sensitivity of Bayes factors to priors.--> 

## Conclusions

To conclude, aging researchers seeking to understand age differences in cognitive processes should consider incorporating cognitive modeling, either in lieu of standard statistical analyses applied to the raw data, or to supplement those analyses with models that parameterize the latent cognitive processes of theoretical or empirical interest.

\newpage

# References

\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}
